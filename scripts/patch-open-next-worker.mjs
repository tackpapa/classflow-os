import { readFileSync, writeFileSync, existsSync } from 'fs'
import { join } from 'path'
import { fileURLToPath } from 'url'
import { dirname } from 'path'
import { config } from 'dotenv'

const __filename = fileURLToPath(import.meta.url)
const __dirname = dirname(__filename)

/**
 * OpenNext Worker.js íŒ¨ì¹˜ ìŠ¤í¬ë¦½íŠ¸
 *
 * ëª©ì :
 * 1. Next.js Full Route Cacheë¥¼ API ìš”ì²­ì—ì„œ ìš°íšŒ (KNOWHOW.md ì„¹ì…˜ 1)
 * 2. í™˜ê²½ë³€ìˆ˜ ë¹Œë“œíƒ€ì„ ì£¼ì… (KNOWHOW.md ì„¹ì…˜ 5)
 *
 * ì°¸ê³ : CLOUDFLARE_MIGRATION_PLAN.md Phase 0
 */

console.log('ğŸ”§ OpenNext Worker.js íŒ¨ì¹˜ ì‹œì‘...\n')

// 1. .env íŒŒì¼ ë¡œë“œ
const envPath = join(process.cwd(), '.env.production')
if (existsSync(envPath)) {
  console.log(`ğŸ“ Loading environment from: ${envPath}`)
  config({ path: envPath })
} else {
  console.warn(`âš ï¸  .env.production not found, using process.env`)
}

// 2. Worker.js ê²½ë¡œ í™•ì¸
const workerPath = join(process.cwd(), '.open-next/worker.js')

if (!existsSync(workerPath)) {
  console.error(`âŒ Error: worker.js not found at ${workerPath}`)
  console.error(`   Please run 'npx @cloudflare/next-on-pages' first`)
  process.exit(1)
}

try {
  let content = readFileSync(workerPath, 'utf-8')
  console.log(`âœ… worker.js loaded (${content.length} bytes)\n`)

  // 3. í™˜ê²½ë³€ìˆ˜ ë¹Œë“œíƒ€ì„ ì£¼ì… (ì„¹ì…˜ 5)
  console.log('ğŸ“ Step 1: Injecting environment variables...')

  const envVars = {
    NEXT_PUBLIC_SUPABASE_URL: process.env.NEXT_PUBLIC_SUPABASE_URL || '',
    NEXT_PUBLIC_SUPABASE_ANON_KEY: process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY || '',
  }

  // í™˜ê²½ë³€ìˆ˜ ê²€ì¦
  if (!envVars.NEXT_PUBLIC_SUPABASE_URL || !envVars.NEXT_PUBLIC_SUPABASE_ANON_KEY) {
    console.error('âŒ Error: Required environment variables not found')
    console.error('   NEXT_PUBLIC_SUPABASE_URL:', envVars.NEXT_PUBLIC_SUPABASE_URL ? 'OK' : 'MISSING')
    console.error('   NEXT_PUBLIC_SUPABASE_ANON_KEY:', envVars.NEXT_PUBLIC_SUPABASE_ANON_KEY ? 'OK' : 'MISSING')
    process.exit(1)
  }

  const envInjection = `
// ğŸ”¥ INJECTED AT BUILD TIME (KNOWHOW.md Section 5)
// Generated by scripts/patch-open-next-worker.mjs
const INJECTED_ENV = ${JSON.stringify(envVars, null, 2)};

if (typeof globalThis !== 'undefined') {
  if (!globalThis.process) globalThis.process = { env: {} };
  if (!globalThis.process.env) globalThis.process.env = {};

  Object.keys(INJECTED_ENV).forEach(key => {
    globalThis.process.env[key] = INJECTED_ENV[key];
  });

  console.log('[OpenNext Patch] âœ… Environment variables injected:', Object.keys(INJECTED_ENV));
}

`

  // íŒŒì¼ ì‹œì‘ ë¶€ë¶„ì— í™˜ê²½ë³€ìˆ˜ ì£¼ì…
  content = envInjection + content
  console.log('   âœ… Environment variables injected')
  console.log('   - NEXT_PUBLIC_SUPABASE_URL:', envVars.NEXT_PUBLIC_SUPABASE_URL.substring(0, 30) + '...')
  console.log('   - NEXT_PUBLIC_SUPABASE_ANON_KEY:', envVars.NEXT_PUBLIC_SUPABASE_ANON_KEY.substring(0, 30) + '...\n')

  // 4. API Cache Bypass íŒ¨ì¹˜ (ì„¹ì…˜ 1)
  console.log('ğŸ“ Step 2: Adding API Cache Bypass...')

  const apiCacheBypassCode = `
// ğŸ”¥ PATCH: API Cache Bypass (KNOWHOW.md Section 1)
// Generated by scripts/patch-open-next-worker.mjs
const isApiRequest = pathname.startsWith('/api/') || pathname.startsWith('/api');

if (isApiRequest) {
  console.log('[OpenNext Patch] ğŸ”¥ API request detected, bypassing all cache layers:', pathname);

  const { handler } = await import("./server-functions/default/handler.mjs");
  const res = await handler(reqOrResp, env, ctx, request.signal);

  // ìºì‹œ ë°©ì§€ í—¤ë” ì¶”ê°€
  res.headers.set('Cache-Control', 'no-store, no-cache, must-revalidate');
  res.headers.set('Pragma', 'no-cache');
  res.headers.set('Expires', '0');
  res.headers.set('x-worker-cache', 'bypass');
  res.headers.set('x-worker-timestamp', Date.now().toString());

  return res;
}
`

  // ì‚½ì… ìœ„ì¹˜ ì°¾ê¸°: "const pathname = url.pathname" ë‹¤ìŒ ì¤„
  const insertMarker = 'const pathname = url.pathname'
  const insertPosition = content.indexOf(insertMarker)

  if (insertPosition === -1) {
    console.error('âŒ Error: Could not find insertion point in worker.js')
    console.error('   Expected to find: "const pathname = url.pathname"')
    console.error('   This might mean the OpenNext structure has changed.')
    process.exit(1)
  }

  // ë‹¤ìŒ ì¤„ë¡œ ì´ë™ (ì¤„ë°”ê¿ˆ ë‹¤ìŒ)
  const nextLinePosition = content.indexOf('\n', insertPosition) + 1

  // íŒ¨ì¹˜ ì½”ë“œ ì‚½ì…
  content =
    content.slice(0, nextLinePosition) +
    apiCacheBypassCode +
    content.slice(nextLinePosition)

  console.log('   âœ… API Cache Bypass patch inserted')
  console.log('   - Insertion point: "const pathname = url.pathname" (line found)')
  console.log('   - Cache headers: Cache-Control, Pragma, Expires, x-worker-cache, x-worker-timestamp\n')

  // 5. íŒŒì¼ ì €ì¥
  writeFileSync(workerPath, content, 'utf-8')

  console.log('âœ… [SUCCESS] OpenNext worker.js patched successfully!\n')
  console.log('ğŸ“‹ Applied patches:')
  console.log('   1. Environment variables injected (KNOWHOW.md Section 5)')
  console.log('   2. API Cache Bypass enabled (KNOWHOW.md Section 1)')
  console.log('')
  console.log('ğŸ¯ Next steps:')
  console.log('   1. Deploy: wrangler pages deploy .vercel/output/static')
  console.log('   2. Verify: curl -i https://your-domain.pages.dev/api/students | grep "x-worker-cache"')
  console.log('   3. Expected: "x-worker-cache: bypass"')
  console.log('')

} catch (error) {
  console.error('âŒ [FAILED] Error patching worker.js:', error.message)
  console.error(error.stack)
  process.exit(1)
}
